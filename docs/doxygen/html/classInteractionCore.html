<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>intprim_framework_ros: InteractionCore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">intprim_framework_ros
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classInteractionCore-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">InteractionCore Class Reference<div class="ingroups"><a class="el" href="group__interaction__core.html">Interaction_core</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="interaction__core_8h_source.html">interaction_core.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a92643ebc71fd9a00a515ffde75fcb9b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInteractionCore.html#a92643ebc71fd9a00a515ffde75fcb9b8">InteractionCore</a> (ros::NodeHandle handle, std::vector&lt; std::unique_ptr&lt; <a class="el" href="classDeviceInterface.html">DeviceInterface</a> &gt;&gt; device_interfaces, std::unique_ptr&lt; <a class="el" href="classPredictorInterface.html">PredictorInterface</a> &gt; predictor_interface)</td></tr>
<tr class="separator:a92643ebc71fd9a00a515ffde75fcb9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880ad29480b6e6e48eb9940b46995a29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInteractionCore.html#a880ad29480b6e6e48eb9940b46995a29">begin_demonstration</a> (unsigned int observation_rate, unsigned int max_observation_length, bool require_clock=false, bool wait_for_control=false, bool check_valid=true)</td></tr>
<tr class="separator:a880ad29480b6e6e48eb9940b46995a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2b19c7051bdcaf7ce0b3954df396bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInteractionCore.html#a0f2b19c7051bdcaf7ce0b3954df396bc">end_demonstration</a> ()</td></tr>
<tr class="separator:a0f2b19c7051bdcaf7ce0b3954df396bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accea05e0b26960fbbff1eb7a0334381b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInteractionCore.html#accea05e0b26960fbbff1eb7a0334381b">export_demonstration</a> (std::string file_name)</td></tr>
<tr class="separator:accea05e0b26960fbbff1eb7a0334381b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997ab9e44015179ebfc0c96bc27000e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInteractionCore.html#a997ab9e44015179ebfc0c96bc27000e4">begin_response</a> (unsigned int observation_rate, unsigned int max_observation_length, unsigned int response_rate, unsigned int minimum_observation_length, bool require_clock=false, bool wait_for_control=false, bool check_valid=true)</td></tr>
<tr class="separator:a997ab9e44015179ebfc0c96bc27000e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f8ccd8954c7cd86a6a1aae4d1979c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInteractionCore.html#af4f8ccd8954c7cd86a6a1aae4d1979c5">end_response</a> ()</td></tr>
<tr class="separator:af4f8ccd8954c7cd86a6a1aae4d1979c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96e7a69e2cceb3d4eac2e245fdee874"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInteractionCore.html#ae96e7a69e2cceb3d4eac2e245fdee874">evaluate_demonstration</a> (std::string file_name, unsigned int minimum_observation_length)</td></tr>
<tr class="separator:ae96e7a69e2cceb3d4eac2e245fdee874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bc2b3f40ad73f941634112085d9d23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInteractionCore.html#a19bc2b3f40ad73f941634112085d9d23">get_statistics</a> (std::string bag_file)</td></tr>
<tr class="separator:a19bc2b3f40ad73f941634112085d9d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classInteractionCore.html">InteractionCore</a> class is responsible for starting and stopping interactions, collecting and synchronizing data, and communicating with the IntPrim Python library in order to generate responses.</p>
<h2>Starting/stopping interactions </h2>
<p>An interaction can take one of two forms: either a train interaction or a test interaction. Train interactions consist of observations which are used to create demonstrations to serve as prior knowledge for the probabilistic model created by Bayesian Interaction Primitives. Test interactions consist of observations which are fed to the probabilistic model created by Bayesian Interaction Primitives in order to generate an appropriate response, e.g., a robot control policy.</p>
<p>As such, starting a train interaction consists of creating a single process to collect and synchronize observations at a given frequency. This is handled by <a class="el" href="classInteractionCore.html#a880ad29480b6e6e48eb9940b46995a29">begin_demonstration()</a>. Once the interaction has been stopped via <a class="el" href="classInteractionCore.html#a0f2b19c7051bdcaf7ce0b3954df396bc">end_demonstration()</a>, the observations may be exported to a CSV for further processing with <a class="el" href="classInteractionCore.html#accea05e0b26960fbbff1eb7a0334381b">export_demonstration()</a>. See introduction.ipynb (LINK THIS) for information on how these files may be utilized to create a BIP prior.</p>
<p>A test interaction is started and ended with <a class="el" href="classInteractionCore.html#a997ab9e44015179ebfc0c96bc27000e4">begin_response()</a> and <a class="el" href="classInteractionCore.html#af4f8ccd8954c7cd86a6a1aae4d1979c5">end_response()</a> respectively. In contrast to training, testing starts two processes which run concurrently: a process which collects and synchronizes observations (the same as in training); and a process which takes the collected observations and passes them off to IntPrim at a given frequency. IntPrim will perform inference and return a predicted response. By default, <a class="el" href="classInteractionCore.html">InteractionCore</a> will publish this response to the ROS topic defined in the rosparam control/control_topic. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Modify such that the topic can be set by the user via ROS parameter.</dd></dl>
<h2>Collecting and synchronizing data </h2>
<p>The collection and synchronization of data is handled by observe(). This function spins at a rate of observation_rate Hz and every iteration collects the latest observation available from each device_interface and appends it to an internal buffer. In order to avoid blocking execution, this function is spun off into its own thread. Note that this is a private function and should <em>not</em> be called externally. It is internally triggered through <a class="el" href="classInteractionCore.html#a880ad29480b6e6e48eb9940b46995a29">begin_demonstration()</a> and <a class="el" href="classInteractionCore.html#a997ab9e44015179ebfc0c96bc27000e4">begin_response()</a>.</p>
<h2>Communicating with IntPrim </h2>
<p>Communication with the IntPrim library is handled by respond(). This function spins at a rate of respond_rate Hz and sends the observations stored in the internal buffer to IntPrim to process via a ROS service. The response from IntPrim is published out to the ROS topic defined in the rosparam control/control_topic. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a92643ebc71fd9a00a515ffde75fcb9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92643ebc71fd9a00a515ffde75fcb9b8">&#9670;&nbsp;</a></span>InteractionCore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InteractionCore::InteractionCore </td>
          <td>(</td>
          <td class="paramtype">ros::NodeHandle&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classDeviceInterface.html">DeviceInterface</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>device_interfaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classPredictorInterface.html">PredictorInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>predictor_interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the <a class="el" href="classInteractionCore.html">InteractionCore</a> instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The ROS node handle </td></tr>
    <tr><td class="paramname">device_interfaces</td><td>A vector of device_interfaces from which observations will be collected. These are polymorphic objects, so the specific device does not matter as long as they fully implement the <a class="el" href="classDeviceInterface.html">DeviceInterface</a> API. </td></tr>
    <tr><td class="paramname">predictor_interface</td><td>The predictor_interface which will be utilized to communicate with IntPrim. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a880ad29480b6e6e48eb9940b46995a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880ad29480b6e6e48eb9940b46995a29">&#9670;&nbsp;</a></span>begin_demonstration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InteractionCore::begin_demonstration </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>observation_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_observation_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>require_clock</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_for_control</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_valid</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Begins a training interaction. Observations are collected at the frequency specified by observation_rate and stored in an internal buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observation_rate</td><td>The rate at which observations are collected (in Hz). </td></tr>
    <tr><td class="paramname">max_observation_length</td><td>The maximum number of observations to keep in the internal buffer. Once this limit is reached, the oldest observation will be dropped when a new one is added. </td></tr>
    <tr><td class="paramname">require_clock</td><td>If true, observations will not be collected until a message is published on the /clock ROS topci. </td></tr>
    <tr><td class="paramname">wait_for_control</td><td>If true, observations will not be collected until a message is published on the control topic. </td></tr>
    <tr><td class="paramname">check_valid</td><td>If true, only valid observations (refer to <a class="el" href="classDeviceInterface.html">DeviceInterface</a> for more details) are collected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a997ab9e44015179ebfc0c96bc27000e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997ab9e44015179ebfc0c96bc27000e4">&#9670;&nbsp;</a></span>begin_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InteractionCore::begin_response </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>observation_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_observation_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>response_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minimum_observation_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>require_clock</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_for_control</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_valid</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Begins a testing interaction. Observations are collected at the frequency specified by observation_rate and stored in an internal buffer. The observations are removed from the buffer and sent to IntPrim at the frequency specified by response_rate. The response from IntPrim is published on the topic defined by the rosparam control/control_topic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observation_rate</td><td>The rate at which observations are collected (in Hz). </td></tr>
    <tr><td class="paramname">max_observation_length</td><td>The maximum number of observations to keep in the internal buffer. Once this limit is reached, the oldest observation will be dropped when a new one is added. </td></tr>
    <tr><td class="paramname">response_rate</td><td>The rate at which the observations are sent to IntPrim for inference. </td></tr>
    <tr><td class="paramname">minimum_observation_length</td><td>The minimum number of observations that must be in the buffer before they are sent to IntPrim. </td></tr>
    <tr><td class="paramname">require_clock</td><td>If true, observations will not be collected until a message is published on the /clock ROS topci. </td></tr>
    <tr><td class="paramname">wait_for_control</td><td>If true, observations will not be collected until a message is published on the control topic. </td></tr>
    <tr><td class="paramname">check_valid</td><td>If true, only valid observations (refer to <a class="el" href="classDeviceInterface.html">DeviceInterface</a> for more details) are collected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f2b19c7051bdcaf7ce0b3954df396bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2b19c7051bdcaf7ce0b3954df396bc">&#9670;&nbsp;</a></span>end_demonstration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InteractionCore::end_demonstration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ends a training interaction. Observations will no longer be collected after this point. </p>

</div>
</div>
<a id="af4f8ccd8954c7cd86a6a1aae4d1979c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f8ccd8954c7cd86a6a1aae4d1979c5">&#9670;&nbsp;</a></span>end_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InteractionCore::end_response </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ends a testing interaction. </p>

</div>
</div>
<a id="ae96e7a69e2cceb3d4eac2e245fdee874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96e7a69e2cceb3d4eac2e245fdee874">&#9670;&nbsp;</a></span>evaluate_demonstration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float InteractionCore::evaluate_demonstration </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minimum_observation_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes an exported demonstration (specified by file_name) and sends it to IntPrim for evaluation in batches of minimum_observation_length. The generated response is compared to the ground truth from the demonstation and the MSE values are calculated. See BayesianInteractionPrimitiveService for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>The name of the demonstration to evaluate. </td></tr>
    <tr><td class="paramname">minimum_observation_length</td><td>The minimum number of observations that must be in the buffer before they are sent to IntPrim.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The overall MSE value of the demonstration. </dd></dl>

</div>
</div>
<a id="accea05e0b26960fbbff1eb7a0334381b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accea05e0b26960fbbff1eb7a0334381b">&#9670;&nbsp;</a></span>export_demonstration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InteractionCore::export_demonstration </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exports the observations currently stored in the internal buffer to a CSV file with the name file_name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>The name of the exported CSV file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19bc2b3f40ad73f941634112085d9d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bc2b3f40ad73f941634112085d9d23">&#9670;&nbsp;</a></span>get_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InteractionCore::get_statistics </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>bag_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exports the statistics and debugging information from the previous interaction. The export directory is dictated by ROS parameters. See BayesianInteractionPrimitiveService for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bag_file</td><td>The name of the ground truth bag file if available, else an empty string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/joe/LibraryRosFramework/intprim_framework_ros/include/intprim_framework_ros/<a class="el" href="interaction__core_8h_source.html">interaction_core.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
