/* @author Joseph Campbell <jacampb1@asu.edu>, Interactive Robotics Lab, Arizona State University */
#pragma once

/*!
    @addtogroup interaction_core
    @{
*/

#include "devices/robot_interface.h"

#include "ros/ros.h"

#include <atomic>
#include <mutex>
#include <thread>

#include <intprim_framework_ros/Trajectory.h>

/*!
    A simple controller which listens for the response output generated by InteractionCore and passes it to a RobotInterface as a reference signal for control.
    The response from InteractionCore is a trajectory of states which the robot should follow.
    This controller spins at the frequency specified by control_frequency and at each iteration sends the next state in the trajectory to the RobotInterface.
    If the RobotInterface is within a given threshold of the current robot state (see RobotInterface for details), then the next state in the trajectory is incremented by 1.
    If the threshold in RobotInterface is 0, then this is equivalent to sending each state in the response trajectory at control_frequency.
*/
class RobotController
{
public:
    /*!
        Initializes the RobotController instance.

        @param handle The ROS node handle.
        @param control_frequency The frequency (in Hz) that this controller will send states to the RobotInterface
        @param robot_interface The RobotInterface which will control the robot.
    */
    RobotController(ros::NodeHandle handle, unsigned int control_frequency, std::unique_ptr<RobotInterface> robot_interface);

    /*!
        Entry point for the RobotController. This is a blocking call.
    */
    void control_robot();

    /*!
        Entry point for the RobotController. This is non-blocking and must be paired with end_control() to stop.
    */
    void start_control();

    /*!
        Exit point for the RobotController. Stops non-blocking control initiated by start_control().
    */
    void end_control();

private:
    ros::Subscriber                     m_controller_listener;
    std::unique_ptr<RobotInterface>     m_robot_interface;

    intprim_framework_ros::Trajectory::ConstPtr        m_current_trajectory;

    std::thread                         m_control_thread;
    std::atomic<bool>                   m_active;
    unsigned int                        m_trajectory_index;
    unsigned int                        m_control_frequency;

    void control_callback(const intprim_framework_ros::Trajectory::ConstPtr& message);

    void control();
};
/** @} */
